<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Foot Pain Mapping Tool</title>
<style>
  body { margin:0; background:#222; color:white; font-family:sans-serif; }
  #ui { position:fixed; top:10px; left:10px; z-index:10; }
  #ui button { margin:2px; }
  canvas { display:block; }
</style>
</head>
<body>
<div id="ui">
  <button id="clearMarkersBtn">Clear Markers (C)</button>
  <button id="exportCSVDetailedBtn">Export CSV Detailed (E)</button>
  <button id="exportCSVAppBtn">Export CSV Appâ€‘Style (A)</button>
  <button id="loadLeftFootBtn">Load Left Foot (L)</button>
  <button id="loadRightFootBtn">Load Right Foot (R)</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>
<script>
let scene, camera, renderer, raycaster, mouse;
let footMesh, colorAttrs = [], markerGroup;
let footSide = 'left';

init();
loadFoot(footSide);

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0.5, 1.2);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
  hemiLight.position.set(0, 1, 0);
  scene.add(hemiLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(1, 1, 1);
  scene.add(dirLight);

  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  markerGroup = new THREE.Group();
  scene.add(markerGroup);

  window.addEventListener('resize', onWindowResize);

  // Click to place marker
  renderer.domElement.addEventListener('click', onClick);

  // Keyboard shortcuts (no arrow keys now)
  window.addEventListener("keydown", (e) => {
    switch (e.key) {
      case "c": case "C":
        clearMarkers();
        break;
      case "e": case "E":
        exportCSV();
        break;
      case "a": case "A":
        exportCSV_AppStyle();
        break;
      case "l": case "L":
        loadFoot("left");
        break;
      case "r": case "R":
        loadFoot("right");
        break;
    }
  });

  // UI buttons
  document.getElementById('clearMarkersBtn').onclick = clearMarkers;
  document.getElementById('exportCSVDetailedBtn').onclick = exportCSV;
  document.getElementById('exportCSVAppBtn').onclick = exportCSV_AppStyle;
  document.getElementById('loadLeftFootBtn').onclick = () => loadFoot("left");
  document.getElementById('loadRightFootBtn').onclick = () => loadFoot("right");

  animate();
}

function loadFoot(side) {
  footSide = side;
  if (footMesh) {
    scene.remove(footMesh);
    footMesh.geometry.dispose();
    footMesh.material.dispose();
  }
  markerGroup.clear();
  colorAttrs = [];

  const loader = new THREE.GLTFLoader();
  loader.load(`${side}_foot_model.glb`, (gltf) => {
    footMesh = gltf.scene.children[0];
    footMesh.traverse(child => {
      if (child.isMesh) {
        child.geometry.computeVertexNormals();
        // Capture all vertexColors attributes for region detection
        for (const key in child.geometry.attributes) {
          if (key.startsWith('color')) {
            colorAttrs.push(child.geometry.attributes[key]);
          }
        }
      }
    });
    scene.add(footMesh);
  });
}

function onClick(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(footMesh, true);
  if (intersects.length > 0) {
    const faceIndex = intersects[0].faceIndex;
    const regions = detectRegionsAtFace(faceIndex);
    addMarker(intersects[0].point, regions);
  }
}

function detectRegionsAtFace(faceIndex) {
  let detectedRegions = [];
  colorAttrs.forEach((attr, idx) => {
    const color = new THREE.Color();
    const i3 = faceIndex * 3;
    color.fromBufferAttribute(attr, i3);
    if (color.r > 0 || color.g > 0 || color.b > 0) {
      detectedRegions.push(`Layer${idx+1}`);
    }
  });
  return detectedRegions;
}

function addMarker(position, regions) {
  const sphere = new THREE.Mesh(
    new THREE.SphereGeometry(0.005, 8, 8),
    new THREE.MeshStandardMaterial({color:0xff0000})
  );
  sphere.position.copy(position);
  sphere.userData.regions = regions;
  markerGroup.add(sphere);
}

function clearMarkers() {
  markerGroup.clear();
}

function exportCSV() {
  let csv = "Marker,Regions\n";
  markerGroup.children.forEach((m, i) => {
    csv += `${i+1},"${m.userData.regions.join(",")}"\n`;
  });
  downloadCSV(csv, "detailed_export.csv");
}

function exportCSV_AppStyle() {
  const allRegions = Array.from(new Set(colorAttrs.map((_,i) => `Layer${i+1}`)));
  let csv = allRegions.join(",") + "\n";
  let row = new Array(allRegions.length).fill(0);
  markerGroup.children.forEach((m) => {
    m.userData.regions.forEach((r) => {
      const idx = allRegions.indexOf(r);
      if (idx >= 0) row[idx] = 1;
    });
  });
  csv += row.join(",") + "\n";
  downloadCSV(csv, "appstyle_export.csv");
}

function downloadCSV(content, filename) {
  const blob = new Blob([content], {type:"text/csv"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
</script>
</body>
</html>
