<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Foot Paint & Detect</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { margin: 0; background: #1c1c1c; color: #f1f1f1; font-family: sans-serif; }
  #ui { position: fixed; top: 10px; left: 10px; z-index: 10; display: flex; flex-wrap: wrap; gap: 6px; }
  #ui button { background: #2b2b2b; color: #f1f1f1; border: 1px solid #3a3a3a; padding: 6px 10px; border-radius: 6px; cursor: pointer; }
  #status { position: fixed; top: 10px; right: 10px; background: #2b2b2b; padding: 6px 10px; border-radius: 6px; font-size: 12px; }
  canvas { display: block; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="ui">
  <button id="clearMarkersBtn">Clear (C)</button>
  <button id="exportCSVDetailedBtn">Export Detailed (E)</button>
  <button id="exportCSVAppBtn">Export App‑Style (A)</button>
  <button id="loadLeftFootBtn">Left Foot (L)</button>
  <button id="loadRightFootBtn">Right Foot (R)</button>
</div>
<div id="status">Loading: idle</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

const urls = {
  left:  "https://stuart-mcneill.github.io/3DFoot/Leftfoot.gltf",
  right: "https://stuart-mcneill.github.io/3DFoot/Rightfoot.gltf"
};

let scene, camera, renderer, controls, raycaster, mouse;
let footRoot, footSide = 'left';
let markerGroup, colorAttrs = [];
let modelReady = false, painting = false;
const statusEl = document.getElementById('status');

init();
loadFoot(footSide);

function setStatus(t) { statusEl.textContent = t; }

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.05, 100);
  camera.position.set(0, 0.35, 1.2);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.minDistance = 0.15;
  controls.maxDistance = 2.0;

  scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.9));
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(1.5, 2, 1.5);
  scene.add(dir);

  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  markerGroup = new THREE.Group();
  scene.add(markerGroup);

  window.addEventListener('resize', onResize);
  renderer.domElement.addEventListener('mousedown', () => { painting = true; });
  renderer.domElement.addEventListener('mouseup',   () => { painting = false; });
  renderer.domElement.addEventListener('mouseleave',() => { painting = false; });
  renderer.domElement.addEventListener('mousemove', onPaint);

  window.addEventListener('keydown', (e) => {
    switch(e.key) {
      case 'c': case 'C': clearMarkers(); break;
      case 'e': case 'E': exportCSVDetailed(); break;
      case 'a': case 'A': exportCSVAppStyle(); break;
      case 'l': case 'L': loadFoot('left'); break;
      case 'r': case 'R': loadFoot('right'); break;
    }
  });

  document.getElementById('clearMarkersBtn').onclick = clearMarkers;
  document.getElementById('exportCSVDetailedBtn').onclick = exportCSVDetailed;
  document.getElementById('exportCSVAppBtn').onclick = exportCSVAppStyle;
  document.getElementById('loadLeftFootBtn').onclick = () => loadFoot('left');
  document.getElementById('loadRightFootBtn').onclick = () => loadFoot('right');

  animate();
}

function loadFoot(side) {
  setStatus(`Loading: ${side} foot…`);
  modelReady = false;
  if (footRoot) {
    scene.remove(footRoot);
    footRoot.traverse(obj => { if (obj.isMesh && obj.geometry) obj.geometry.dispose(); });
    footRoot = null;
  }
  clearMarkers(); colorAttrs = [];

  new GLTFLoader().load(urls[side], gltf => {
    footRoot = gltf.scene;
    footRoot.traverse(obj => {
      if (obj.isMesh && obj.geometry) {
        obj.geometry.computeVertexNormals();
        obj.frustumCulled = false;
        for (const key in obj.geometry.attributes) {
          if (key.toLowerCase().startsWith('color')) {
            const id = colorAttrs.length;
            colorAttrs.push({ mesh: obj, attr: obj.geometry.attributes[key], name: `Layer${id+1}` });
          }
        }
      }
    });
    scene.add(footRoot);
    modelReady = true;
    footSide = side;
    setStatus(`Ready: ${side} foot loaded`);
  });
}

function onPaint(e) {
  if (!painting || !modelReady) return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObject(footRoot, true);
  if (!hits.length) return;
  const hit = hits[0];
  const regions = detectRegionsAtFace(hit.object, hit.faceIndex);
  if (regions.length) addMarker(hit.point, regions);
}

function detectRegionsAtFace(mesh, faceIndex) {
  const geom = mesh.geometry;
  if (!geom || faceIndex == null) return [];
  let a, b, c;
  if (geom.index) {
    a = geom.index.getX(faceIndex*3);
    b = geom.index.getX(faceIndex*3+1);
    c = geom.index.getX(faceIndex*3+2);
  } else {
    a = faceIndex*3; b = faceIndex*3+1; c = faceIndex*3+2;
  }
  const regs = [];
  const localAttrs = colorAttrs.filter(en => en.mesh === mesh);
  const black = new THREE.Color(0,0,0);
  for (const entry of localAttrs) {
    const ca = new THREE.Color().fromBufferAttribute(entry.attr, a);
    const cb = new THREE.Color().fromBufferAttribute(entry.attr, b);
    const cc = new THREE.Color().fromBufferAttribute(entry.attr, c);
    if (!ca.equals(black) || !cb.equals(black) || !cc.equals(black)) regs.push(entry.name);
  }
  return regs;
}

function addMarker(pos, regions) {
  const sph = new THREE.Mesh(
    new THREE.SphereGeometry(0.004, 8, 8),
    new THREE.MeshBasicMaterial({ color: 0xff4444 })
  );
  sph.position.copy(pos);
  sph.userData = { regions };
  markerGroup.add(sph);
}

function clearMarkers() { markerGroup.clear(); }

// DETAILED CSV (Marker -> Region list)
function exportCSVDetailed() {
  if (!markerGroup.children.length) return;
  const rows = [['Marker', 'Regions']];
  markerGroup.children.forEach((m, i) =>
    rows.push([i + 1, m.userData.regions.join('|')])
  );
  downloadCSV(rows, `${footSide}_detailed.csv`);
}

// APP-STYLE CSV (Binary activation grid)
function exportCSVAppStyle() {
  if (!markerGroup.children.length) return;
  // TODO: Replace with your exact clinical region order per side
  const regionOrder = footSide === 'left'
    ? ['Layer1','Layer2','Layer3','Layer4','Layer5','Layer6','Layer7','Layer8','Layer9','Layer10']
    : ['Layer1','Layer2','Layer3','Layer4','Layer5','Layer6','Layer7','Layer8','Layer9','Layer10'];

  const active = {};
  markerGroup.children.forEach(m =>
    m.userData.regions.forEach(r => { active[r] = true; })
  );

  const binaryRow = regionOrder.map(r => active[r] ? 1 : 0);
  const rows = [['PatientID', ...regionOrder], ['ExampleID', ...binaryRow]];
  downloadCSV(rows, `${footSide}_appstyle.csv`);
}

// CSV helper
function downloadCSV(rows, filename) {
  const csvContent = rows.map(r =>
    r.map(v => `"${String(v).replace(/"/g, '""')}"`).join(',')
  ).join('\r\n');
  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

// Resize + loop
function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
</script>
</body>
</html>
