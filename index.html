<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Foot Region Debug Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; background: #dfe6ee; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { display: block; }
    #info {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0,0,0,0.75); color: #fff; padding: 8px 12px;
      font-size: 14px; border-radius: 8px; max-width: 46ch; white-space: pre-line;
    }
    #buttons {
      position: absolute; top: 10px; right: 10px; display: flex; flex-wrap: wrap; gap: 8px;
    }
    button {
      background: #333; color: #fff; border: none; padding: 6px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;
    }
    button:hover { background: #555; }
    #footer {
      position: absolute; bottom: 10px; left: 10px;
      background: rgba(0,0,0,0.65); color: #fff; padding: 6px 10px; border-radius: 6px; font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="info">Loading...</div>
  <div id="buttons">
    <button id="leftBtn">Left Foot</button>
    <button id="rightBtn">Right Foot</button>
    <button id="prevLayerBtn">◀︎ Prev layer</button>
    <button id="nextLayerBtn">Next layer ▶︎</button>
    <button id="clearMarksBtn">Clear marks</button>
    <button id="exportCsvBtn">Export CSV (Detailed)</button>
    <button id="exportAppCsvBtn">Export CSV (App‑style)</button>
  </div>
  <div id="footer">Shortcuts: ←/→ layers • C clear • E export detailed • A export app‑style • L/R switch foot</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js?module";
    import { OrbitControls } from "https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js?module";
    import { GLTFLoader } from "https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js?module";

    // --- Data -----------------------------------------------------------------
    const urls = {
      left:  "https://stuart-mcneill.github.io/3DFoot/Leftfoot.gltf",
      right: "https://stuart-mcneill.github.io/3DFoot/Rightfoot.gltf"
    };

    const regionMaps = {
      left: { /* ... your full left foot COLOR_n -> name mapping ... */ },
      right: { /* ... your full right foot COLOR_n -> name mapping ... */ }
    };

    const ALL_COLOR_ATTRS = Array.from({ length: 36 }, (_, i) => `COLOR_${i}`);

    // App‑style order arrays (unchanged)
    const APP_LEFT_ORDER = [/* ...full left order list... */];
    const APP_RIGHT_ORDER = [...APP_LEFT_ORDER];

    const REGION_ALIASES = new Map([
      ["plantar mtj 4", "Plantar MTP 4"]
    ]);

    function toAppLabel(side, label) {
      if (!label) return null;
      const lower = label.trim().toLowerCase();
      const bank = side === "right" ? APP_RIGHT_ORDER : APP_LEFT_ORDER;
      const alias = REGION_ALIASES.get(lower);
      if (alias && bank.includes(alias)) return alias;
      const found = bank.find(n => n.toLowerCase() === lower);
      return found || null;
    }

    // --- State ----------------------------------------------------------------
    let currentFoot = "left";
    let currentRoot = null;
    let targetMesh = null;
    let colorAttrs = [];
    let currentIndex = 0;

    const markers = [];
    const markMeta = [];

    const infoEl = document.getElementById("info");

    // --- Scene ----------------------------------------------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdfe6ee);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(0, 1, 2);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(3, 10, 10);
    scene.add(dir);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const loader = new GLTFLoader();

    // --- Helpers --------------------------------------------------------------
    function disposeObject3D(obj) { /* unchanged */ }
    function clearMarkers() { /* unchanged */ }
    function pickTargetMesh(root) { /* unchanged */ }
    function fitCameraToObject(object, offset = 1.25) { /* unchanged */ }
    async function buildColorLayersFromParser(gltf, geometry) { /* unchanged */ }

    function applyColorLayer() { /* unchanged, purely visual */ }

    function updateInfo(regionName = null, attrName = null) { /* unchanged */ }

    // --- Multi‑region detection -----------------------------------------------
    const FACE_PAINT_EPS = 0.01;
    function detectRegionsAtFace(intersect) {
      const face = intersect.face;
      const geometry = intersect.object?.geometry || targetMesh?.geometry;
      if (!face || !geometry) return [];
      const i1 = face.a, i2 = face.b, i3 = face.c;
      const found = [];
      for (const attrName of colorAttrs) {
        const colorAttr = geometry.attributes[attrName];
        if (!colorAttr) continue;
        const c1 = new THREE.Color().fromArray(colorAttr.array, i1 * 3);
        const c2 = new THREE.Color().fromArray(colorAttr.array, i2 * 3);
        const c3 = new THREE.Color().fromArray(colorAttr.array, i3 * 3);
        const v1 = c1.r + c1.g + c1.b;
        const v2 = c2.r + c2.g + c2.b;
        const v3 = c3.r + c3.g + c3.b;
        if (v1 > FACE_PAINT_EPS && v2 > FACE_PAINT_EPS && v3 > FACE_PAINT_EPS) {
          const regionName = regionMaps[currentFoot]?.[attrName] || "Unknown Region";
          found.push({ attrName, regionName });
        }
      }
      return found;
    }

    // --- Interaction ----------------------------------------------------------
    function onClick(event) {
      if (!targetMesh) return;
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(targetMesh, true);
      if (!intersects.length) return;
      const intersect = intersects[0];
      const matches = detectRegionsAtFace(intersect);
      placeMarker(intersect.point, matches, intersect);
    }

    function placeMarker(position, matches, intersect) {
      const marker = new THREE.Mesh(
        new THREE.SphereGeometry(0.005, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xff0000 })
      );
      marker.position.copy(position);
      scene.add(marker);
      markers.push({ mesh: marker });

      // FIX: store actual match list for export, independent of visible layer
      const regions = matches.map(m => m.regionName);
      const layers = matches.map(m => m.attrName);

      markMeta.push({
        foot: currentFoot,
        x: position.x, y: position.y, z: position.z,
        faceIndex: intersect.faceIndex ?? -1,
        matchedRegions: regions,     // array of names
        matchedLayers: layers,       // array of attr names
        iso8601: new Date().toISOString()
      });

      updateInfo();
    }

    // --- Exports --------------------------------------------------------------
    function csvEscape(s) { /* unchanged */ }

    function exportCSV() { /* unchanged detailed export */ }

    function exportCSV
        function exportCSV_AppStyle() {
      const leftFlags  = Array(APP_LEFT_ORDER.length).fill(0);
      const rightFlags = Array(APP_RIGHT_ORDER.length).fill(0);

      for (const m of markMeta) {
        const side = (m.foot || "").toLowerCase() === "right" ? "right" : "left";

        // Loop through every matched region from the click
        for (const region of m.matchedRegions || []) {
          const appLabel = toAppLabel(side, region || "");
          if (!appLabel) continue;
          const bank = side === "right" ? APP_RIGHT_ORDER : APP_LEFT_ORDER;
          const idx = bank.indexOf(appLabel);
          if (idx >= 0) {
            if (side === "right") rightFlags[idx] = 1;
            else leftFlags[idx] = 1;
          }
        }
      }

      const row1 = [
        "Left Foot",
        ...Array.from({length: APP_LEFT_ORDER.length}, (_, i) => String(i + 1)),
        "Right Foot",
        ...Array.from({length: APP_RIGHT_ORDER.length}, (_, i) => String(i + 1))
      ];

      const row2 = [
        "",
        ...APP_LEFT_ORDER,
        "",
        ...APP_RIGHT_ORDER
      ];

      const row3 = [
        "",
        ...leftFlags.map(String),
        "",
        ...rightFlags.map(String)
      ];

      const csv = [row1, row2, row3].map(r => r.join(",")).join("\n");
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `foot_regions_appstyle_${new Date().toISOString().replace(/[:.]/g,"-")}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // --- Loading --------------------------------------------------------------
    async function loadFoot(side) {
      if (currentRoot) {
        scene.remove(currentRoot);
        disposeObject3D(currentRoot);
        currentRoot = null;
        targetMesh = null;
      }
      clearMarkers();
      infoEl.textContent = `Loading ${side} foot…`;

      loader.load(
        urls[side],
        async (gltf) => {
          currentFoot = side;
          currentRoot = gltf.scene;
          scene.add(currentRoot);

          targetMesh = pickTargetMesh(currentRoot);
          if (!targetMesh) {
            infoEl.textContent = "No mesh found in model.";
            return;
          }

          currentRoot.traverse((obj) => {
            if (obj.isMesh) {
              obj.material = new THREE.MeshStandardMaterial({
                vertexColors: true, metalness: 0.0, roughness: 1.0
              });
            }
          });

          await buildColorLayersFromParser(gltf, targetMesh.geometry);
          currentIndex = 0;
          applyColorLayer();
          fitCameraToObject(currentRoot, 1.25);
        },
        undefined,
        (error) => {
          console.error("Error loading GLTF:", error);
          infoEl.textContent = "Load error. Check console.";
        }
      );
    }

    // --- Events ---------------------------------------------------------------
    window.addEventListener("click", onClick);

    window.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "ArrowRight":
          if (!colorAttrs.length) break;
          currentIndex = (currentIndex + 1) % colorAttrs.length; applyColorLayer(); break;
        case "ArrowLeft":
          if (!colorAttrs.length) break;
          currentIndex = (currentIndex - 1 + colorAttrs.length) % colorAttrs.length; applyColorLayer(); break;
        case "c": case "C":
          clearMarkers(); break;
        case "e": case "E":
          exportCSV(); break;               // detailed
        case "a": case "A":
          exportCSV_AppStyle(); break;      // app-style
        case "l": case "L":
          loadFoot("left"); break;
        case "r": case "R":
          loadFoot("right"); break;
      }
    });

    document.getElementById("leftBtn").onclick = () => loadFoot("left");
    document.getElementById("rightBtn").onclick = () => loadFoot("right");
    document.getElementById("prevLayerBtn").onclick = () => {
      if (!colorAttrs.length) return;
      currentIndex = (currentIndex - 1 + colorAttrs.length) % colorAttrs.length; applyColorLayer();
    };
    document.getElementById("nextLayerBtn").onclick = () => {
      if (!colorAttrs.length) return;
      currentIndex = (currentIndex + 1) % colorAttrs.length; applyColorLayer();
    };
    document.getElementById("clearMarksBtn").onclick = clearMarkers;
    document.getElementById("exportCsvBtn").onclick = exportCSV;
    document.getElementById("exportAppCsvBtn").onclick = exportCSV_AppStyle;

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Loop -----------------------------------------------------------------
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Initial load
    loadFoot("left");
  </script>
</body>
</html>
