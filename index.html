<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Foot Region Debug Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; background: #dfe6ee; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { display: block; }
    #info {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0,0,0,0.75); color: #fff; padding: 8px 12px;
      font-size: 14px; border-radius: 8px; max-width: 46ch; white-space: pre-line;
    }
    #buttons {
      position: absolute; top: 10px; right: 10px; display: flex; flex-wrap: wrap; gap: 8px;
    }
    button {
      background: #333; color: #fff; border: none; padding: 6px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;
    }
    button:hover { background: #555; }
    #footer {
      position: absolute; bottom: 10px; left: 10px;
      background: rgba(0,0,0,0.65); color: #fff; padding: 6px 10px; border-radius: 6px; font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="info">Loading...</div>
  <div id="buttons">
    <button id="leftBtn">Left Foot</button>
    <button id="rightBtn">Right Foot</button>
    <button id="prevLayerBtn">◀︎ Prev layer</button>
    <button id="nextLayerBtn">Next layer ▶︎</button>
    <button id="clearMarksBtn">Clear marks</button>
    <button id="exportCsvBtn">Export CSV (Detailed)</button>
    <button id="exportAppCsvBtn">Export CSV (App‑style)</button>
  </div>
  <div id="footer">Shortcuts: ←/→ layers • C clear • E export detailed • A export app‑style • L/R switch foot</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js?module";
    import { OrbitControls } from "https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js?module";
    import { GLTFLoader } from "https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js?module";

    // --- Data -----------------------------------------------------------------
    const urls = {
      left:  "https://stuart-mcneill.github.io/3DFoot/Leftfoot.gltf",
      right: "https://stuart-mcneill.github.io/3DFoot/Rightfoot.gltf"
    };

    const regionMaps = {
      left: {
        COLOR_0: "Medial Arch", COLOR_1: "Plantar Toe 1", COLOR_2: "Dorsal MTP 1", COLOR_3: "Plantar MTP 1",
        COLOR_4: "Dorsal Toe 2", COLOR_5: "Plantar Toe 2", COLOR_6: "Dorsal MTP 2", COLOR_7: "Plantar MTP 2",
        COLOR_8: "Dorsal Toe 3", COLOR_9: "Plantar Toe 3", COLOR_10: "Dorsal MTP 3", COLOR_11: "Plantar MTP 3",
        COLOR_12: "Dorsal Toe 4", COLOR_13: "Plantar Toe 4", COLOR_14: "Dorsal MTP 4", COLOR_15: "Plantar MTJ 4",
        COLOR_16: "Dorsal Toe 5", COLOR_17: "Plantar Toe 5", COLOR_18: "Dorsal MTP 5", COLOR_19: "Plantar MTP 5",
        COLOR_20: "Dorsal Midfoot", COLOR_21: "Dorsal Ankle", COLOR_22: "Plantar Lateral", COLOR_23: "Plantar Heel",
        COLOR_24: "Posterior Heel", COLOR_25: "Posterior Insertion", COLOR_26: "Posterior Midportion",
        COLOR_27: "Posterior Leg", COLOR_28: "Medial MTP", COLOR_29: "Medial Midfoot", COLOR_30: "Lateral Midfoot",
        COLOR_31: "Posterior Medial", COLOR_32: "Posterior Lateral", COLOR_33: "Medial Leg", COLOR_34: "Lateral Leg",
        COLOR_35: "Dorsal Toe 1"
      },
      right: {
        COLOR_0: "Dorsal Toe 1", COLOR_1: "Plantar Toe 1", COLOR_2: "Dorsal MTP 1", COLOR_3: "Plantar MTP 1",
        COLOR_4: "Dorsal Toe 2", COLOR_5: "Plantar Toe 2", COLOR_6: "Dorsal MTP 2", COLOR_7: "Plantar MTP 2",
        COLOR_8: "Dorsal Toe 3", COLOR_9: "Plantar Toe 3", COLOR_10: "Dorsal MTP 3", COLOR_11: "Plantar MTP 3",
        COLOR_12: "Dorsal Toe 4", COLOR_13: "Plantar Toe 4", COLOR_14: "Dorsal MTP 4", COLOR_15: "Plantar MTJ 4",
        COLOR_16: "Dorsal Toe 5", COLOR_17: "Plantar Toe 5", COLOR_18: "Dorsal MTP 5", COLOR_19: "Plantar MTP 5",
        COLOR_20: "Dorsal Midfoot", COLOR_21: "Dorsal Ankle", COLOR_22: "Medial Arch", COLOR_23: "Plantar Lateral",
        COLOR_24: "Plantar Heel", COLOR_25: "Posterior Heel", COLOR_26: "Posterior Insertion",
        COLOR_27: "Posterior Midportion", COLOR_28: "Posterior Leg", COLOR_29: "Medial MTP", COLOR_30: "Medial Midfoot",
        COLOR_31: "Lateral Midfoot", COLOR_32: "Posterior Medial", COLOR_33: "Posterior Lateral",
        COLOR_34: "Medial Leg", COLOR_35: "Lateral Leg"
      }
    };

    const ALL_COLOR_ATTRS = Array.from({ length: 36 }, (_, i) => `COLOR_${i}`);

    // --- App‑style export definitions (match the app’s CSV row 2 exactly) ----
    const APP_LEFT_ORDER = [
      "Dorsal toe 1","Dorsal toe 2","Dorsal toe 3","Dorsal toe 4","Dorsal toe 5",
      "Dorsal MTP 1","Dorsal MTP 2","Dorsal MTP 3","Dorsal MTP 4","Dorsal MTP 5",
      "Dorsal midfoot","Dorsal ankle",
      "Plantar toe 1","Plantar toe 2","Plantar toe 3","Plantar toe 4","Plantar toe 5",
      "Plantar MTP 1","Plantar MTP 2","Plantar MTP 3","Plantar MTP 4","Plantar MTP 5",
      "Medial arch","Plantar lateral","Plantar heel",
      "Posterior heel","Posterior insertion","Posterior midportion","Posterior leg",
      "Medial MTP","Medial midfoot","Posterior medial","Medial leg","Lateral midfoot","Posterior lateral","Lateral leg"
    ];
    const APP_RIGHT_ORDER = [...APP_LEFT_ORDER];

    // Normalize your model labels to the app’s label if wording differs (case handled elsewhere)
    const REGION_ALIASES = new Map([
      ["plantar mtj 4", "Plantar MTP 4"]  // MTJ vs MTP difference
    ]);

    function toAppLabel(side, label) {
      if (!label) return null;
      const lower = label.trim().toLowerCase();
      const bank = side === "right" ? APP_RIGHT_ORDER : APP_LEFT_ORDER;
      const alias = REGION_ALIASES.get(lower);
      if (alias && bank.includes(alias)) return alias;
      const found = bank.find(n => n.toLowerCase() === lower);
      return found || null;
    }

    // --- State ----------------------------------------------------------------
    let currentFoot = "left";
    let currentRoot = null;
    let targetMesh = null;
    let colorAttrs = [];
    let currentIndex = 0;

    const markers = [];   // [{ mesh }]
    const markMeta = [];  // rows for CSV (per marker)

    // --- Scene ----------------------------------------------------------------
    const infoEl = document.getElementById("info");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdfe6ee);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(0, 1, 2);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(3, 10, 10);
    scene.add(dir);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const loader = new GLTFLoader();

    // --- Helpers --------------------------------------------------------------
    function disposeObject3D(obj) {
      obj.traverse((o) => {
        if (o.isMesh) {
          o.geometry?.dispose();
          const m = o.material;
          if (m) {
            if (Array.isArray(m)) m.forEach(mat => mat.dispose());
            else m.dispose();
          }
        }
      });
    }

    function clearMarkers() {
      for (const m of markers) scene.remove(m.mesh);
      markers.length = 0;
      markMeta.length = 0;
      updateInfo();
    }

    function pickTargetMesh(root) {
      let best = null, bestScore = -1;
      root.traverse((obj) => {
        if (obj.isMesh && obj.geometry) {
          const triCount = obj.geometry.index ? obj.geometry.index.count / 3 : (obj.geometry.attributes.position.count / 3);
          if (triCount > bestScore) { best = obj; bestScore = triCount; }
        }
      });
      return best;
    }

    function fitCameraToObject(object, offset = 1.25) {
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let camZ = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
      camZ *= offset;

      camera.near = maxDim / 100;
      camera.far = maxDim * 100;
      camera.updateProjectionMatrix();

      camera.position.set(center.x + camZ * 0.4, center.y + camZ * 0.2, center.z + camZ);
      controls.target.copy(center);
      controls.update();
    }

    async function buildColorLayersFromParser(gltf, geometry) {
      colorAttrs.length = 0;
      const json = gltf.parser.json;
      const prim = json.meshes?.[0]?.primitives?.[0];
      const attrs = prim?.attributes || {};

      for (const key in attrs) {
        if (!key.startsWith("COLOR_")) continue;
        const accessorIndex = attrs[key];
        const accessor = await gltf.parser.getDependency("accessor", accessorIndex);
        geometry.setAttribute(
          key,
          new THREE.BufferAttribute(accessor.array, accessor.itemSize, accessor.normalized)
        );
        colorAttrs.push(key);
      }

      // Include any missing expected COLOR_* names to keep layer UI consistent
      const present = new Set(colorAttrs);
      for (const key of ALL_COLOR_ATTRS) if (!present.has(key)) colorAttrs.push(key);

      colorAttrs.sort((a, b) => parseInt(a.split("_")[1]) - parseInt(b.split("_")[1]));
    }

    function applyColorLayer() {
      if (!targetMesh || !colorAttrs.length) return;
      const attrName = colorAttrs[currentIndex];
      const regionName = regionMaps[currentFoot]?.[attrName] || "Unknown Region";
      const g = targetMesh.geometry;

      if (g.attributes[attrName]) {
        g.setAttribute("color", g.attributes[attrName]);
        g.attributes.color.needsUpdate = true;
      } else {
        if (g.attributes.color) {
          const count = g.attributes.position.count;
          const dummy = new Float32Array(count * 3);
          g.setAttribute("color", new THREE.BufferAttribute(dummy, 3));
          g.attributes.color.needsUpdate = true;
        }
      }
      updateInfo(regionName, attrName);
    }

    function updateInfo(regionName = null, attrName = null) {
      const idxInfo = colorAttrs.length ? `Layer ${currentIndex + 1}/${colorAttrs.length}` : "No color layers";
      const attrInfo = attrName || (colorAttrs[currentIndex] ?? "–");
      const regionInfo = regionName || (regionMaps[currentFoot]?.[attrInfo] ?? "Unknown Region");
      infoEl.textContent = `Foot: ${currentFoot}
${idxInfo}
Attr: ${attrInfo}
Region: ${regionInfo}
Markers: ${markers.length}
Click anywhere: regions are auto-detected across all layers (strict face ownership)
Keys: ←/→ layers (visual only), C clear, E export detailed, A export app‑style, L/R switch foot`;
    }

    // --- Multi-region detection (independent of visible layer) ---------------
    const FACE_PAINT_EPS = 0.01;

    function detectRegionsAtFace(intersect) {
      const face = intersect.face;
      const geometry = intersect.object?.geometry || targetMesh?.geometry;
      if (!face || !geometry) return [];

      const i1 = face.a, i2 = face.b, i3 = face.c;
      const found = [];

      for (const attrName of colorAttrs) {
        const colorAttr = geometry.attributes[attrName];
        if (!colorAttr) continue;

        const c1 = new THREE.Color().fromArray(colorAttr.array, i1 * 3);
        const c2 = new THREE.Color().fromArray(colorAttr.array, i2 * 3);
        const c3 = new THREE.Color().fromArray(colorAttr.array, i3 * 3);
        const v1 = c1.r + c1.g + c1.b;
        const v2 = c2.r + c2.g + c2.b;
        const v3 = c3.r + c3.g + c3.b;

        // Strict face ownership: all three vertices must be painted in this layer
        if (v1 > FACE_PAINT_EPS && v2 > FACE_PAINT_EPS && v3 > FACE_PAINT_EPS) {
          const regionName = regionMaps[currentFoot]?.[attrName] || "Unknown Region";
          found.push({ attrName, regionName });
        }
      }

      return found;
    }

    // --- Interaction ----------------------------------------------------------
    function onClick(event) {
      if (!targetMesh) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(targetMesh, true);
      if (!intersects.length) return;

      const intersect = intersects[0];
      const matches = detectRegionsAtFace(intersect);

      placeMarker(intersect.point, matches, intersect);
    }

    function placeMarker(position, matches, intersect) {
      const marker = new THREE.Mesh(
        new THREE.SphereGeometry(0.005, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xff0000 })
      );
      marker.position.copy(position);
      scene.add(marker);
      markers.push({ mesh: marker });

      const top = matches[0];
      const regions = matches.map(m => m.regionName).join("; ");
      const layers = matches.map(m => m.attrName).join("; ");

      markMeta.push({
        foot: currentFoot,
        x: position.x, y: position.y, z: position.z,
        faceIndex: intersect.faceIndex ?? -1,
        topRegion: top ? top.regionName : "Unmapped",
        allRegions: regions,
        layers: layers,
        iso8601: new Date().toISOString()
      });

      updateInfo();

      if (matches.length) {
        console.log("Full-face matches (strict ownership):");
        matches.forEach(m => console.log(`- ${m.regionName} [${m.attrName}]`));
      } else {
        console.log("No regions detected with strict face ownership at this triangle.");
      }
    }

    // --- Exports --------------------------------------------------------------
    function csvEscape(s) {
      const str = String(s ?? "");
      return `"${str.replace(/"/g, '""')}"`;
    }

    // Detailed per-marker export (your original style)
    function exportCSV() {
      if (!markMeta.length) return;
      const headers = ["foot","x","y","z","faceIndex","topRegion","allRegions","layers","iso8601"];
      const rows = markMeta.map(m => [
        m.foot,
        m.x.toFixed(6), m.y.toFixed(6), m.z.toFixed(6),
        m.faceIndex,
        csvEscape(m.topRegion),
        csvEscape(m.allRegions),
        csvEscape(m.layers),
        m.iso8601
      ]);
      const csv = [headers.join(","), ...rows.map(r => r.join(","))].join("\n");
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `foot_markers_detailed_${currentFoot}_${new Date().toISOString().replace(/[:.]/g,"-")}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // App-style export (binary grid by region per foot)
    function exportCSV_AppStyle() {
      const leftFlags  = Array(APP_LEFT_ORDER.length).fill(0);
      const rightFlags = Array(APP_RIGHT_ORDER.length).fill(0);

      for (const m of markMeta) {
        const side = (m.foot || "").toLowerCase() === "right" ? "right" : "left";
        const appLabel = toAppLabel(side, m.topRegion || "");
        if (!appLabel) continue;
        const bank = side === "right" ? APP_RIGHT_ORDER : APP_LEFT_ORDER;
        const idx = bank.indexOf(appLabel);
        if (idx >= 0) {
          if (side === "right") rightFlags[idx] = 1;
          else leftFlags[idx] = 1;
        }
      }

      const row1 = [
        "Left Foot",
        ...Array.from({length: APP_LEFT_ORDER.length}, (_, i) => String(i + 1)),
        "Right Foot",
        ...Array.from({length: APP_RIGHT_ORDER.length}, (_, i) => String(i + 1))
      ];

      const row2 = [
        "",
        ...APP_LEFT_ORDER,
        "",
        ...APP_RIGHT_ORDER
      ];

      const row3 = [
        "",
        ...leftFlags.map(String),
        "",
        ...rightFlags.map(String)
      ];

      const csv = [row1, row2, row3].map(r => r.join(",")).join("\n");
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `foot_regions_appstyle_${new Date().toISOString().replace(/[:.]/g,"-")}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // --- Loading --------------------------------------------------------------
    async function loadFoot(side) {
      if (currentRoot) {
        scene.remove(currentRoot);
        disposeObject3D(currentRoot);
        currentRoot = null;
        targetMesh = null;
      }
      clearMarkers();
      infoEl.textContent = `Loading ${side} foot…`;

      loader.load(
        urls[side],
        async (gltf) => {
          currentFoot = side;
          currentRoot = gltf.scene;
          scene.add(currentRoot);

          targetMesh = pickTargetMesh(currentRoot);
          if (!targetMesh) {
            infoEl.textContent = "No mesh found in model.";
            return;
          }

          currentRoot.traverse((obj) => {
            if (obj.isMesh) {
              obj.material = new THREE.MeshStandardMaterial({
                vertexColors: true, metalness: 0.0, roughness: 1.0
              });
            }
          });

          await buildColorLayersFromParser(gltf, targetMesh.geometry);
          currentIndex = 0;
          applyColorLayer();
          fitCameraToObject(currentRoot, 1.25);
        },
        undefined,
        (error) => {
          console.error("Error loading GLTF:", error);
          infoEl.textContent = "Load error. Check console.";
        }
      );
    }

    // --- Events ---------------------------------------------------------------
    window.addEventListener("click", onClick);

    window.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "ArrowRight":
          if (!colorAttrs.length) break;
          currentIndex = (currentIndex + 1) % colorAttrs.length; applyColorLayer(); break;
        case "ArrowLeft":
          if (!colorAttrs.length) break;
          currentIndex = (currentIndex - 1 + colorAttrs.length) % colorAttrs.length; applyColorLayer(); break;
        case "c": case "C":
          clearMarkers(); break;
        case "e": case "E":
          exportCSV(); break;               // detailed
        case "a": case "A":
          exportCSV_AppStyle(); break;      // app-style
        case "l": case "L":
          loadFoot("left"); break;
        case "r": case "R":
          loadFoot("right"); break;
      }
    });

    document.getElementById("leftBtn").onclick = () => loadFoot("left");
    document.getElementById("rightBtn").onclick = () => loadFoot("right");
    document.getElementById("prevLayerBtn").onclick = () => {
      if (!colorAttrs.length) return;
      currentIndex = (currentIndex - 1 + colorAttrs.length) % colorAttrs.length; applyColorLayer();
    };
    document.getElementById("nextLayerBtn").onclick = () => {
      if (!colorAttrs.length) return;
      currentIndex = (currentIndex + 1) % colorAttrs.length; applyColorLayer();
    };
    document.getElementById("clearMarksBtn").onclick = clearMarkers;
    document.getElementById("exportCsvBtn").onclick = exportCSV;
    document.getElementById("exportAppCsvBtn").onclick = exportCSV_AppStyle;

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Loop -----------------------------------------------------------------
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Initial load
    loadFoot("left");
  </script>
</body>
</html>
