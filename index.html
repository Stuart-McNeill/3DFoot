<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Foot Pain Mapping Tool</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { color-scheme: dark; }
  body { margin: 0; background: #1c1c1c; color: #f1f1f1; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  #ui { position: fixed; top: 10px; left: 10px; z-index: 10; display: flex; flex-wrap: wrap; gap: 6px; }
  #ui button { background: #2b2b2b; color: #f1f1f1; border: 1px solid #3a3a3a; padding: 6px 10px; border-radius: 6px; cursor: pointer; }
  #ui button:hover { background: #333; }
  #status { position: fixed; top: 10px; right: 10px; z-index: 10; background: #2b2b2b; border: 1px solid #3a3a3a; padding: 6px 10px; border-radius: 6px; font-size: 12px; opacity: 0.9; }
  canvas { display: block; }
</style>
</head>
<body>
  <div id="ui">
    <button id="clearMarkersBtn">Clear Markers (C)</button>
    <button id="exportCSVDetailedBtn">Export CSV Detailed (E)</button>
    <button id="exportCSVAppBtn">Export CSV App‑Style (A)</button>
    <button id="loadLeftFootBtn">Load Left Foot (L)</button>
    <button id="loadRightFootBtn">Load Right Foot (R)</button>
  </div>
  <div id="status">Loading: idle</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
    // Optional for QA: orbit controls
    // import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';

    const urls = {
      left:  "https://stuart-mcneill.github.io/3DFoot/Leftfoot.gltf",
      right: "https://stuart-mcneill.github.io/3DFoot/Rightfoot.gltf"
    };

    let scene, camera, renderer, raycaster, mouse;
    let footRoot = null;
    let footSide = 'left';
    let markerGroup;
    let colorAttrs = []; // { mesh, attr, key }
    let modelReady = false;
    const statusEl = document.getElementById('status');

    init();
    loadFoot(footSide);

    function setStatus(text) { statusEl.textContent = text; }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.05, 100);
      camera.position.set(0, 0.35, 1.2);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x222233, 0.9);
      hemiLight.position.set(0, 1, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
      dirLight.position.set(1.5, 2, 1.5);
      scene.add(dirLight);

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      markerGroup = new THREE.Group();
      scene.add(markerGroup);

      // Optional controls for QA
      // const controls = new OrbitControls(camera, renderer.domElement);
      // controls.enableDamping = true;

      window.addEventListener('resize', onWindowResize);
      renderer.domElement.addEventListener('click', onClick);

      // Keyboard shortcuts (no arrow keys)
      window.addEventListener("keydown", (e) => {
        switch (e.key) {
          case "c": case "C": clearMarkers(); break;
          case "e": case "E": exportCSV(); break;
          case "a": case "A": exportCSV_AppStyle(); break;
          case "l": case "L": loadFoot("left"); break;
          case "r": case "R": loadFoot("right"); break;
        }
      });

      // UI buttons
      document.getElementById('clearMarkersBtn').onclick = clearMarkers;
      document.getElementById('exportCSVDetailedBtn').onclick = exportCSV;
      document.getElementById('exportCSVAppBtn').onclick = exportCSV_AppStyle;
      document.getElementById('loadLeftFootBtn').onclick = () => loadFoot("left");
      document.getElementById('loadRightFootBtn').onclick = () => loadFoot("right");

      animate();
      function animate() {
        requestAnimationFrame(animate);
        // controls && controls.update();
        renderer.render(scene, camera);
      }
    }

    function loadFoot(side) {
      setStatus(`Loading: ${side} foot…`);
      modelReady = false;

      // Remove previous model
      if (footRoot) {
        scene.remove(footRoot);
        footRoot.traverse(obj => {
          if (obj.isMesh) {
            if (obj.geometry) obj.geometry.dispose();
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => { if (m && m.dispose) m.dispose(); });
            } else if (obj.material && obj.material.dispose) {
              obj.material.dispose();
            }
          }
        });
        footRoot = null;
      }
      // Clear markers and color attributes
      clearMarkers();
      colorAttrs = [];

      const loader = new GLTFLoader();
      loader.load(
        urls[side],
        (gltf) => {
          footRoot = gltf.scene;
          // Gather all vertex color layers per mesh
          footRoot.traverse(obj => {
            if (obj.isMesh && obj.geometry) {
              obj.geometry.computeVertexNormals();
              obj.frustumCulled = false;
              const attrs = obj.geometry.attributes;
              for (const key in attrs) {
                if (key.toLowerCase().startsWith('color')) {
                  colorAttrs.push({ mesh: obj, attr: attrs[key], key });
                }
              }
              if (obj.material && 'vertexColors' in obj.material) {
                obj.material.vertexColors = true;
              }
            }
          });
          scene.add(footRoot);
          modelReady = true;
          setStatus(`Ready: ${side} foot loaded (${colorAttrs.length} color layers)`);
        },
        (xhr) => {
          if (xhr.total) {
            const pct = Math.round((xhr.loaded / xhr.total) * 100);
            setStatus(`Loading: ${side} foot… ${pct}%`);
          }
        },
        (err) => {
          console.error('GLTF load error:', err);
          setStatus('Error: failed to load foot model.');
        }
      );
    }

    function onClick(event) {
      if (!modelReady || !footRoot) return;

      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(footRoot, true);
      if (!intersects.length) return;

      const hit = intersects[0];
      const regions = detectRegionsAtFace(hit.object, hit.faceIndex);
      addMarker(hit.point, regions);
    }

    // Face-based region detection that works for indexed and non-indexed geometry
    function detectRegionsAtFace(mesh, faceIndex) {
      const geom = mesh.geometry;
      if (!geom || faceIndex == null) return [];

      let a, b, c;
      if (geom.index) {
        a = geom.index.getX(faceIndex * 3 + 0);
        b = geom.index.getX(faceIndex * 3 + 1);
        c = geom.index.getX(faceIndex * 3 + 2);
      } else {
        a = faceIndex * 3 + 0;
        b = faceIndex * 3 + 1;
        c = faceIndex * 3 + 2;
      }

      const regions = [];
      const localAttrs = colorAttrs.filter(entry => entry.mesh === mesh);
      for (let i = 0; i < localAttrs.length; i++) {
        const entry = localAttrs[i];
        const attr = entry.attr;

        const ca = new THREE.Color().fromBufferAttribute(attr, a);
        const cb = new THREE.Color().fromBufferAttribute(attr, b);
        const cc = new THREE.Color().fromBufferAttribute(attr, c);

        const present =
          (ca.r + ca.g + ca.b) > 0.0001 ||
          (cb.r + cb.g + cb.b) > 0.0001 ||
          (cc.r + cc.g + cc.b) > 0.0001;

        if (present) regions.push(`Layer${i + 1}`);
      }
      return regions;
    }

    function addMarker(position, regions) {
      const sphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.005, 12, 12),
        new THREE.MeshStandardMaterial({ color: 0xff4444, metalness: 0.0, roughness: 0.6 })
      );
      sphere.position.copy(position);
      sphere.userData.regions = regions;
      markerGroup.add(sphere);
    }

    function clearMarkers() {
      for (let i = markerGroup.children.length - 1; i >= 0; i--) {
        const m = markerGroup.children[i];
        if (m.geometry && m.geometry.dispose) m.geometry.dispose();
        if (m.material) {
          if (Array.isArray(m.material)) m.material.forEach(mat => mat && mat.dispose && mat.dispose());
          else if (m.material.dispose) m.material.dispose();
        }
        markerGroup.remove(m);
      }
    }

    function exportCSV() {
      let csv = "Marker,Regions\n";
      for (let i = 0; i < markerGroup.children.length; i++) {
        const m = markerGroup.children[i];
        const regions = (m.userData && m.userData.regions) ? m.userData.regions : [];
        csv += `${i + 1},"${regions.join(",")}"\n`;
      }
      downloadCSV(csv, "detailed_export.csv");
    }

    function exportCSV_AppStyle() {
      // Ordered layer list (current mesh-local order; can be replaced with clinical order)
      const layers = [];
      const seen = new Set();
      for (let i = 0; i < colorAttrs.length; i++) {
        const name = `Layer${i + 1}`;
        if (!seen.has(name)) {
          layers.push(name);
          seen.add(name);
        }
      }

      const row = new Array(layers.length).fill(0);
      for (let m of markerGroup.children) {
        const regions = (m.userData && m.userData.regions) ? m.userData.regions : [];
        for (let r of regions) {
          const idx = layers.indexOf(r);
          if (idx >= 0) row[idx] = 1;
        }
      }

      let csv = layers.join(",") + "\n" + row.join(",") + "\n";
      downloadCSV(csv, "appstyle_export.csv");
    }

    function downloadCSV(content, filename) {
      const blob = new Blob([content], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
